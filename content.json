{"meta":{"title":"PersonalBlog","subtitle":null,"description":null,"author":"佛系码农","url":"https:// keandfan.github.io/blog"},"pages":[],"posts":[{"title":"loading动画以及旋转立方体","slug":"loading动画以及旋转立方体","date":"2018-06-11T04:26:21.000Z","updated":"2018-06-11T13:01:46.312Z","comments":true,"path":"2018/06/11/loading动画以及旋转立方体/","link":"","permalink":"https:// keandfan.github.io/blog/2018/06/11/loading动画以及旋转立方体/","excerpt":"loading效果","text":"loading效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;CSS3动画实现loading效果&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; .circlebox&#123; width: 40px; height: 40px; margin: 100px; position: absolute; &#125; .circlebox p&#123; width: 12px; height: 12px; border-radius: 50%; background: red; position: absolute; animation: move 1.5s infinite linear; &#125; .circlebox p:nth-of-type(1)&#123;left: 0;top: 0;&#125; .circlebox p:nth-of-type(2)&#123;right: 0;top: 0;&#125; .circlebox p:nth-of-type(3)&#123;right: 0;bottom: 0;&#125; .circlebox p:nth-of-type(4)&#123;left: 0;bottom: 0;&#125; .circlebox:nth-of-type(2)&#123;transform: rotate(45deg)&#125; @keyframes move&#123; 0%&#123;transform: scale(0);&#125; 50%&#123;transform: scale(1);&#125; 100%&#123;transform: scale(0);&#125; &#125; .circlebox:nth-of-type(1) p:nth-of-type(1)&#123;animation-delay: -0.1s;&#125; .circlebox:nth-of-type(2) p:nth-of-type(1)&#123;animation-delay: -0.3s;&#125; .circlebox:nth-of-type(1) p:nth-of-type(2)&#123;animation-delay: -0.5s;&#125; .circlebox:nth-of-type(2) p:nth-of-type(2)&#123;animation-delay: -0.7s;&#125; .circlebox:nth-of-type(1) p:nth-of-type(3)&#123;animation-delay: -0.9s;&#125; .circlebox:nth-of-type(2) p:nth-of-type(3)&#123;animation-delay: -1.1s;&#125; .circlebox:nth-of-type(1) p:nth-of-type(4)&#123;animation-delay: -1.3s;&#125; .circlebox:nth-of-type(2) p:nth-of-type(4)&#123;animation-delay: -1.5s;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;circlebox&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;circlebox&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 旋转立方体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS3实现立方体&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; .box&#123; width: 400px; height: 400px; border: 4px solid red; margin: 30px auto; perspective: 1000px; &#125; .box ul&#123; width: 300px; height: 300px; border: 1px solid blue; margin: 50px auto; position: relative; transform-style: preserve-3d; animation: move 4S infinite linear; transform-origin: center center -150px; &#125; .box ul li&#123; width: 300px ; height: 300px; list-style: none; font-size: 50px; color: #fff; text-align: center; line-height: 300px; position: absolute; &#125; .box ul li:nth-of-type(1)&#123;background: red;opacity: 0.4;&#125; .box ul li:nth-of-type(2)&#123;background: blue;opacity: 0.4;transform:translateX(300px) rotateY(90deg); transform-origin: left;&#125; .box ul li:nth-of-type(3)&#123;background: yellow;opacity: 0.4;transform:translateX(-300px) rotateY(-90deg); transform-origin: right;&#125; .box ul li:nth-of-type(4)&#123;background: green;opacity: 0.4; transform: translateY(-300px) rotateX(90deg); transform-origin: bottom; &#125; .box ul li:nth-of-type(5)&#123;background: darkorange;opacity: 0.4;transform: translateY(300px) rotateX(-90deg); transform-origin: top; &#125; .box ul li:nth-of-type(6)&#123;background: pink;opacity: 0.4;transform: translateZ(-300px) rotateY(180deg);&#125; @keyframes move&#123; from&#123;transform: rotateY(0);&#125; to&#123;transform: rotateY(360deg);&#125; &#125; &lt;/style&gt; &lt;!-- 1.定位 2.移动物体位置 transform: translate 平移 rotate旋转 X水平的轴 Y表示垂直的轴 Z表示屏幕垂直的轴 3.3D场景的设置 transform-style:perserve-3d;是需要添加到所有变形元素的父元素上 perspective:1000px 景深 看物体远近 数值大小表示远近 越大越远 4.动画animation 动画的轨迹是写在keyframs 里面 --&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"https:// keandfan.github.io/blog/tags/CSS3/"}]},{"title":"继承","slug":"继承","date":"2018-06-08T02:05:31.000Z","updated":"2018-06-08T02:11:22.644Z","comments":true,"path":"2018/06/08/继承/","link":"","permalink":"https:// keandfan.github.io/blog/2018/06/08/继承/","excerpt":"js继承1234567891011121314/** * 借助构造函数实现继承 */function Parent1()&#123; this.name = &apos;parent&apos;;&#125;//Parent1.prototype.say = function()&#123;&#125;;//给父类原型添加一个say方法，但此方法子类通过call/apply不能继承function Child1()&#123; Parent1.call(this);//apply也可以实现继承 //这里实现继承的原理就是通过call/apply使父级方法的this指向子类 this.type = &apos;child&apos;;&#125;//console.log(new Child1,new Parent1());","text":"js继承1234567891011121314/** * 借助构造函数实现继承 */function Parent1()&#123; this.name = &apos;parent&apos;;&#125;//Parent1.prototype.say = function()&#123;&#125;;//给父类原型添加一个say方法，但此方法子类通过call/apply不能继承function Child1()&#123; Parent1.call(this);//apply也可以实现继承 //这里实现继承的原理就是通过call/apply使父级方法的this指向子类 this.type = &apos;child&apos;;&#125;//console.log(new Child1,new Parent1()); 123456789101112131415161718/** * 借助原型链实现继承 */function Parent2()&#123; this.name = &apos;parent2&apos;; this.play = [1,2,3];&#125;function Child2()&#123; this.type = &apos;child2&apos;;&#125;Child2.prototype = new Parent2();console.log(new Child2())var s1 = new Child2();var s2 = new Child2();s1.play.push(4);console.log(s1.play,s2.play); //两个的原型prototype一样，constructor一样，所以原型上的方法也是一样，S1/S2里的play增加一个数，相当于修改原型上的方法，所有继承这个 方法的实例全都会改变 12345678910111213141516/** * 组合方式 */function Parent3()&#123; this.name = &apos;parent&apos;; this.play = [1,2,3];&#125;function Child3()&#123; Parent3.call(this); this.type = &apos;child3&apos;;&#125;Child3.prototype = new Parent3();var s3 = new Child3();var s4 = new Child3();s3.play.push(4);console.log(s3.play,s4.play); 1234567891011121314151617/** * 组合继承的优化1 */function Parent4()&#123; this.name = &apos;parent4&apos;; this.play = [1,2,3];&#125;function Child4()&#123; Parent4.call(this); this.type = &apos;child4&apos;;&#125;Child4.prototype = Parent4.prototype;var s5 = new Child4();var s6 = new Child4();s5.play.push(4);console.log(s5,s6);//只优化了prototype 而constructor还是一样的 1234567891011121314151617181920/** * 组合继承优化2 */function Parent5()&#123; this.name = &apos;parent5&apos;; this.play = [1,2,3];&#125;function Child5()&#123; Parent4.call(this); this.type = &apos;child5&apos;;&#125;Child5.prototype = Object.create(Parent5.prototype);Child5.prototype.constructor = Child5;var s7 = new Child5();var s8 = new Child5();console.log(s7 instanceof Child5,s7 instanceof Parent5);console.log(s7.constructor);//通过Object连接修改原型，prototype不会同时改变，而construcor通过重新赋值也不会跟父类相同。","categories":[],"tags":[{"name":"js学习","slug":"js学习","permalink":"https:// keandfan.github.io/blog/tags/js学习/"}]},{"title":"遍历多维数组","slug":"遍历多维数组","date":"2018-05-14T14:55:41.000Z","updated":"2018-05-16T05:40:51.066Z","comments":true,"path":"2018/05/14/遍历多维数组/","link":"","permalink":"https:// keandfan.github.io/blog/2018/05/14/遍历多维数组/","excerpt":"","text":"遍历多维数组 遍历一维数组（Array each方法） 1234var arr = [1,2,3,4,5];arr.forEach(function(item,index,array)&#123; alert(item); //1 2 3 4 5 &#125;); 自己实现一个Array each方法，能遍历多维数组 123456789101112131415161718192021222324252627282930313233var arr = [1,2,3,[4,[5,[6]]]]Array.prototype.each = function(fn) &#123; try&#123; //1.遍历数组的每一项 this.i || (this.i = 0); //初始化i(减少声明，ES5) //2.判断什么时候走核心代码 if(this.length&gt;0 &amp;&amp; fn.constructor === Function)&#123; //遍历 while(this.i &lt; this.length)&#123; //while循环的范围 //获取数组的每一项 var e = this[this.i]; //如果当前元素获取到了，并且当前元素是一个数组 if(e &amp;&amp; e.constructor === Array)&#123; //递归 e.each(fn); &#125;else&#123; //如果不是数组，即就是元素 //将数组元素传递给fn fn.call(e,e); &#125; this.i++ &#125; this.i = null; //释放内存 垃圾回收机制 &#125; &#125;catch(ex)&#123; //do someting &#125; return this;&#125;arr.each(function(item)&#123; console.log(item); // 1 2 3 4 5 6&#125;)","categories":[],"tags":[{"name":"js学习","slug":"js学习","permalink":"https:// keandfan.github.io/blog/tags/js学习/"}]},{"title":"去除数组重复元素","slug":"去除数组重复元素","date":"2018-05-14T12:32:32.000Z","updated":"2018-05-14T12:40:38.218Z","comments":true,"path":"2018/05/14/去除数组重复元素/","link":"","permalink":"https:// keandfan.github.io/blog/2018/05/14/去除数组重复元素/","excerpt":"","text":"给数组去除重复元素（原生js） 12345678910111213141516171819202122232425262728// 去除数组重复元素 var arr = [1,2,2,3,5,4,8,6,4,2,47,5,9,3,20,3]; //将数组转为对象，将key传入对象，对象中key值不允许重复 var toNewObject = function(arr)&#123; var obj = &#123;&#125;; var len = arr.length; for(var i = 0;i&lt;len;i++)&#123; obj[arr[i]] = true; &#125; return obj; &#125; //将对象转成数组 var toNewArr = function(obj)&#123; var arr = []; for(var attr in obj)&#123; if(obj.hasOwnProperty(attr))&#123; arr.push(attr); &#125; &#125; return arr; &#125; //通过函数输出筛选后的数组 var unique = function(arr)&#123; var obj = toNewObject(arr); var newArr = toNewArr(obj); return newArr; &#125; console.log(unique(arr));","categories":[],"tags":[{"name":"js学习","slug":"js学习","permalink":"https:// keandfan.github.io/blog/tags/js学习/"}]},{"title":"ES6学习","slug":"ES6学习","date":"2018-05-14T12:21:30.000Z","updated":"2018-05-14T12:21:30.098Z","comments":true,"path":"2018/05/14/ES6学习/","link":"","permalink":"https:// keandfan.github.io/blog/2018/05/14/ES6学习/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"U盘启动盘制作与系统安装","slug":"U盘启动盘制作与系统安装","date":"2018-05-14T09:27:32.000Z","updated":"2018-05-14T11:49:57.985Z","comments":true,"path":"2018/05/14/U盘启动盘制作与系统安装/","link":"","permalink":"https:// keandfan.github.io/blog/2018/05/14/U盘启动盘制作与系统安装/","excerpt":"U盘制作（求人不如求己系列-最纯净的U盘制作以及系统安装）（以下均为个人喜好） 准备工具 U盘、WPE（tips:U盘最好8G以上，制作U盘本身只需要几M，但是一般制作U盘是为了装系统，一般系统大小是大于4G的） 为什么推荐WPE呢？（我不解释你就不下了是吧）： WPE相比较与什么老某桃、某菜什么一堆启动盘来说，绝对纯净（希望后续版本不要打我脸），绝对纯净的意思呢，就是你用WPE制作的U盘，将系统放进u盘里，安装完系统，然后开机不会发现那些有的没的广告（前提系统没有广告，系统的事后面再说，急个啥子）。 WPE官网：http://uds8.njxdmyd.cn/109.html","text":"U盘制作（求人不如求己系列-最纯净的U盘制作以及系统安装）（以下均为个人喜好） 准备工具 U盘、WPE（tips:U盘最好8G以上，制作U盘本身只需要几M，但是一般制作U盘是为了装系统，一般系统大小是大于4G的） 为什么推荐WPE呢？（我不解释你就不下了是吧）： WPE相比较与什么老某桃、某菜什么一堆启动盘来说，绝对纯净（希望后续版本不要打我脸），绝对纯净的意思呢，就是你用WPE制作的U盘，将系统放进u盘里，安装完系统，然后开机不会发现那些有的没的广告（前提系统没有广告，系统的事后面再说，急个啥子）。 WPE官网：http://uds8.njxdmyd.cn/109.html 什么时候可以用到这个U盘启动盘 当你忘记管理员密码，当你需要安装新系统（需要把后面系统放进U盘），里面都有相应的功能（具体往后看） 安装完WPE之后，打开无需安装，界面如下（我用的老版本，新版本应该会更好看） 说话两小时，安装一分钟。（注意制作U盘启动盘会格式化你的U盘，请注意备份） 制作完U盘后还是可以当U盘正常使用，格式化之后就不能当启动盘也就是不能装系统了。 关于U盘格式 exFAT：可以存大于几百M的文件（推荐） FAT32：只能存小于400M还是多大的文件 NTFS: 一般用于系统盘，不适用于U盘，具体百度，我只能跟你说这么多 关于系统 跟U盘启动盘软件一样，好多系统文件有广告 我推荐”专注于Win7” ，无他，主要是纯净没广告 官网：http://www.newxitong.com/ 64位系统跟32位系统的区别 64位听起来就要厉害一点啊 如果你电脑内存大于4G，推荐用64位，小于4G，推荐32位（当然小于4G可以去买个内存条加进去） 实际操作 将下载好的系统（按你个人喜好），直接复制进你制作完成的U盘里面，好了，你U盘无敌了。 安装新系统： 进入U盘系统（这里装系统只针对原系统是WIN7或者XP的用户） 1.电脑关机 2.U盘插入电脑 3.按下开机键狂按F8（具体系统不一样）选择你的U盘启动 4.进入U盘系统界面 直接点击那个锤子+蓝色文件夹的图标，安装，OK，安装系统就这么简单。C盘会格式化，从经验来看。 需要分区就点分区工具：需要整个将你系统的东西删掉的话，进入分区工具，将各个盘删除（盘里东西都没了），保存，点击快速分区，自己喜好分多大几个G 如果想其他盘东西不动，直接格式化C盘保存，然后出来，直接点击那个锤子+蓝色文件夹的图标，安装. 管理员密码的话找U盘系统里面的密码工具，更改-解锁。","categories":[],"tags":[{"name":"生活常用","slug":"生活常用","permalink":"https:// keandfan.github.io/blog/tags/生活常用/"}]}]}